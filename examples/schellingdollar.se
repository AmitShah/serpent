# Hedged zero-supply dollar implementation
# Uses SchellingCoin as price-determining backend
#
# contract.storage[1] contains the lowest stored epoch
# contract.storage[2] contains the highest stored epoch
# contract.storage[3] contains the starting block
# contract.storage[4] contains the contract's global ETH exposure
# contract.storage[5] contains the contract's global USD exposure
# contract.storage[EPOCHSTORE+3k+0] contains the USD price in wei in epoch k
# contract.storage[EPOCHSTORE+3k+1] contains the per-epoch interest rate at that epoch, times 10^9
# contract.storage[EPOCHSTORE+3k+2] contains an interest rate accumulator
# contract.storage[2^160 - 1] contains the number of hashed votes
# contract.storage[2^160...] is the array of hash votes
# contract.storage[2^180...] is the array of 
# contract.storage[ACCOUNTS+addr] contains the ether amount
# contract.storage[ACCOUNTS+addr+1] contains the USD amount
# contract.storage[ACCOUNTS+addr+2] contains the last accessed epoch

shared:
    NUM_HASHED_VOTES = 2^160 - 1
    HASHED_VOTES = 2^160
    TOTAL_DEPOSIT = 2^170 - 1    
    DEPOSITS = 2^170
    REVEALED_VOTES = 2^180
    SCHELLING_COIN = contract.storage[0]
    LAST_EPOCH = 1
    STARTING_BLOCK = 2
    USD_EXPOSURE = 3
    ETH_EXPOSURE = 4
    EPOCHSTORE = 5
    ACCOUNTS = 2^161
init:
    contract.storage[0] = create('schellingcoin.se')
    contract.storage[LAST_EPOCH] = EPOCHSTORE
    contract.storage[STARTING_BLOCK] = block.number
    contract.storage[EPOCHSTORE] = 10^10 # test with a cheap dollar
    contract.storage[EPOCHSTORE + 1] = 0
    contract.storage[EPOCHSTORE + 2] = 2^128

code:
    sender = msg.sender
    epoch = (block.number - contract.storage[STARTING_BLOCK]) / 1000
    subindex = (block.number - contract.storage[STARTING_BLOCK]) % 1000
    last_epoch = contract.storage[LAST_EPOCH]

    # Update contract epochs
    if epoch > last_epoch:
        # The idea is that we manipulate the interest rate by a factor of 0.01% per epoch,
        # increasing it if the contract is long USD (ie. people are short USD) and
        # decreasing it if the contract is short USD
        # An alternative strategy is to control the interest rate directly instead of
        # controlling the derivative; experimentation will likely be needed to see which
        # is better; in reality hybrid PID controllers tend to win, though those may be
        # overkill since we like simplicity
        if contract.storage[USD_EXPOSURE] < 0:
            contract.storage[last_epoch + 4] = contract.storage[pointer + 1] - 10000
        else:
            contract.storage[last_epoch + 4] = contract.storage[pointer + 1] + 10000
        
        contract.storage[last_epoch + 5] = contract.storage[last_epoch + 2] * contract.storage[last_epoch + 4] / 10^9

    contract.storage[LAST_EPOCH] = last_epoch

    price = call(SCHELLING_COIN, 4)

    # Now, the API begins

    # Useful variables
    my_acct = ACCOUNTS + msg.sender
    recv_acct = ACCOUNTS + msg.data[1]

    # Apply interest rates to sender
    call(contract.address, 12)

    # Liquidation-test self
    call(contract.address, 11)
    
    # Send ETH (to, value)
    if msg.data[0] == 1:
        if msg.data[2] > 0 and msg.data[2] < ethbal and usdbal * usdval * 50 + (ethbal - msg.data[2]) * 45 >= 0:
            contract.storage[my_acct] = ethbal - msg.data[2]
            call(contract.address, [0, msg.data[1]], 2)
            contract.storage[recv_acct] += msg.data[2]
            return(1)
    # Send USD (to, value)
    elif msg.data[0] == 2:
        if msg.data[2] > 0 and (usdbal - msg.data[2]) * usdval * 50 + ethbal * 45 >= 0:
            contract.storage[my_acct + 1] = usdbal - msg.data[2]
            call(contract.address,[0, msg.data[1]], 2)
            contract.storage[recv_acct + 1] += msg.data[2]
            return(1)
    # Convert USD to ETH (usdvalue)
    elif msg.data[0] == 3:
        if msg.data[1] > 0:
            usdminus = msg.data[1]
            ethplus = usdminus * usdval * 999 / 1000
            debug(usdbal - usdminus)
            debug((usdbal - usdminus) * usdval)
            debug(ethbal + ethplus)
            if (usdbal - usdminus) * usdval * 50 + (ethbal + ethplus) * 45 >= 0:
                contract.storage[my_acct] = ethbal + ethplus
                contract.storage[my_acct + 1] = usdbal - usdminus
                contract.storage[ETH_EXPOSURE] += ethplus
                contract.storage[USD_EXPOSURE] -= usdminus
            return([ethbal + ethplus, usdbal - usdminus], 2)
    # Convert ETH to USD (ethvalue)
    elif msg.data[0] == 4:
        if msg.data[1] >= 0 and msg.data[1] < ethbal:
            usdplus = msg.data[1] / usdval * 999 / 1000
            ethminus = msg.data[1]
            if (usdbal + usdplus) * 50 + (ethbal - ethminus) * usdval * 45 >= 0:
                contract.storage[my_acct] = ethbal - ethminus
                contract.storage[my_acct + 1] = usdbal + usdplus
                contract.storage[ETH_EXPOSURE] -= ethminus
                contract.storage[USD_EXPOSURE] += usdplus
            return([ethbal - ethminus, usdbal + usdplus], 2)
    # Deposit
    elif msg.data[0] == 5:
        contract.storage[ACCOUNTS + sender] = ethbal + msg.value
        contract.storage[ETH_EXPOSURE] = contract.storage[ETH_EXPOSURE] + msg.value
        return(ethbal + msg.value)
    # Withdraw (ethvalue)
    elif msg.data[0] == 6:
        if msg.data[1] >= 0 and msg.data[1] <= ethbal:
            contract.storage[myacct] = ethbal - msg.data[1]
            contract.storage[ETH_EXPOSURE] -= msg.data[1]
            send(msg.sender, msg.data[1])
            return(ethbal - msg.data[1])
    # Balance query
    elif msg.data[0] == 9:
        return([ethbal, usdbal], 2)
    # Global state query
    elif msg.data[0] == 10:
        price = contract.storage[last_epoch]
        interest = contract.storage[last_epoch + 1]
        return([last_epoch, price, interest], 3)
    # Liquidation test any account, with bounty for success
    elif msg.data[0] == 11:
        ethbal = contract.storage[recv_acct]
        usdbal = contract.storage[recv_acct + 1]
        if usdbal * usdval * 50 + ethbal * 45 < 0:
            contract.storage[ETH_EXPOSURE] = contract.storage[ETH_EXPOSURE] - ethbal
            contract.storage[USD_EXPOSURE] = contract.storage[USD_EXPOSURE] + usdbal
            send(msg.sender, ethbal / 10)
            contract.storage[recv_acct] = 0
            contract.storage[recv_acct + 1] = 0
            return(1)
        return(0)
    # Apply interest rates to account
    elif msg.data[0] == 12:
        account_last_epoch = contract.storage[recv_acct + 2] or EPOCHSTORE
        if account_last_epoch != last_epoch:
            cur_balance = contract.storage[recv_acct + 1]
            new_balance = cur_balance * contract.storage[last_epoch + 2] / contract.storage[account_last_epoch + 2]
            contract.storage[recv_acct + 1] = new_balance
            contract.storage[recv_acct + 2] = last_epoch
        
