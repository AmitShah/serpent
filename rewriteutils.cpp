#include <stdio.h>
#include <iostream>
#include <vector>
#include <map>
#include "util.h"
#include "lllparser.h"
#include "bignum.h"
#include "rewriteutils.h"
#include "optimize.h"

// Cool function for debug purposes (named cerrStringList to make
// all prints searchable via 'cerr')
void cerrStringList(std::vector<std::string> s, std::string suffix) {
    for (unsigned i = 0; i < s.size(); i++) std::cerr << s[i] << " ";
    std::cerr << suffix << "\n";
}

// Convert:
// self.cow -> ["cow"]
// self.horse[0] -> ["horse", "0"]
// self.a[6][7][self.storage[3]].chicken[9] -> 
//     ["6", "7", (sload 3), "chicken", "9"]
std::vector<Node> listfyStorageAccess(Node node) {
    std::vector<Node> out;
    std::vector<Node> nodez;
    nodez.push_back(node);
    while (1) {
        if (nodez.back().type == TOKEN) {
            out.push_back(token("--" + nodez.back().val, node.metadata));
            std::vector<Node> outrev;
            for (int i = (signed)out.size() - 1; i >= 0; i--) {
                outrev.push_back(out[i]);
            }
            return outrev;
        }
        if (nodez.back().val == ".")
            nodez.back().args[1].val = "--" + nodez.back().args[1].val;
        if (nodez.back().args.size() == 0)
            err("Error parsing storage variable statement", node.metadata);
        if (nodez.back().args.size() == 1)
            out.push_back(token(tt256m1, node.metadata));
        else
            out.push_back(nodez.back().args[1]);
        nodez.push_back(nodez.back().args[0]);
    }
}

// Is the given node something of the form
// self.cow
// self.horse[0]
// self.a[6][7][self.storage[3]].chicken[9]
bool isNodeStorageVariable(Node node) {
    std::vector<Node> nodez;
    nodez.push_back(node);
    while (1) {
        if (nodez.back().type == TOKEN) return false;
        if (nodez.back().args.size() == 0) return false;
        if (nodez.back().val != "." && nodez.back().val != "access")
            return false;
        if (nodez.back().args[0].val == "self") return true;
        nodez.push_back(nodez.back().args[0]);
    }
}

// Main pattern matching routine, for those patterns that can be expressed
// using our standard mini-language above
//
// Returns two values. First, a boolean to determine whether the node matches
// the pattern, second, if the node does match then a map mapping variables
// in the pattern to nodes
matchResult match(Node p, Node n) {
    matchResult o;
    o.success = false;
    if (p.type == TOKEN) {
        if (p.val == n.val && n.type == TOKEN) o.success = true;
        else if (p.val[0] == '$' || p.val[0] == '@') {
            o.success = true;
            o.map[p.val.substr(1)] = n;
        }
    }
    else if (n.type==TOKEN || p.val!=n.val || p.args.size()!=n.args.size()) {
        // do nothing
    }
    else {
		for (unsigned i = 0; i < p.args.size(); i++) {
            matchResult oPrime = match(p.args[i], n.args[i]);
            if (!oPrime.success) {
                o.success = false;
                return o;
            }
            for (std::map<std::string, Node>::iterator it = oPrime.map.begin();
                 it != oPrime.map.end();
                 it++) {
                o.map[(*it).first] = (*it).second;
            }
        }
        o.success = true;
    }
    return o;
}


// Counts the number of instances of variables
// Assume while and until loops iterate twice
msi countVars(Node pattern, std::map<std::string, Node> dict, msi o = msi(), bool inLoop=false) {
    if (pattern.type == TOKEN) {
        if (pattern.val.size() &&
            dict.count(pattern.val.substr(1)) && 
            pattern.val[0] == '$') o[pattern.val.substr(1)] += inLoop ? 2 : 1;
    }
    bool inLoopSub = inLoop || (pattern.val == "while" || pattern.val == "until");
    for (unsigned i = 0; i < pattern.args.size(); i++) {
        o = countVars(pattern.args[i], dict, o, inLoopSub);
    }
    return o;
}

// Fills in the pattern with a dictionary mapping variable names to
// nodes (these dicts are generated by match). Match and subst together
// create a full pattern-matching engine. 
Node subst(Node pattern,
           std::map<std::string, Node> dict,
           std::string varflag,
           Metadata m) {
    // Swap out patterns at the token level
    if (pattern.type == TOKEN && 
            (pattern.val[0] == '$' || pattern.val[0] == '@')) {
        if (dict.count(pattern.val.substr(1))) {
            return dict[pattern.val.substr(1)];
        }
        else {
            return token(varflag + pattern.val.substr(1), m);
        }
    }
    // Other tokens are untouched
    else if (pattern.type == TOKEN) {
        return pattern;
    }
    else {
        // Step 1: count the variables, for ASTs that need to be used
        // more than once, we convert them into stack variables, and
        // put the stack variable into subst
        std::vector<Node> with;
        msi vars = countVars(pattern, dict);
        for (msi::iterator it = vars.begin(); it != vars.end(); it++) {
            if ((*it).second > 1 && !isDegenerate(dict[(*it).first])) {
                with.push_back(
                    astnode("with",
                            token(varflag + (*it).first, m),
                            dict.count((*it).first) 
                                ? dict[(*it).first] 
                                : token("0", m),
                            token("0", m),
                            m));
                dict[(*it).first] =
                    token(varflag + (*it).first, m);
                std::cerr << printSimple(token(varflag + (*it).first, m)) << "\n";
            }
        }
        // Step 2: substitute recursively
        std::vector<Node> args;
		for (unsigned i = 0; i < pattern.args.size(); i++) {
            args.push_back(subst(pattern.args[i], dict, varflag, m));
        }
        // Step 3: apply with statements
        Node o = astnode(pattern.val, args, m);
        for (int i = (int)with.size() - 1; i >= 0; i--) {
            o = astnode("with", with[i].args[0], with[i].args[1], o, m);
        }
        return o;
    }
}
